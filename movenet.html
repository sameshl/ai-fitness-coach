<!DOCTYPE html>
<html>
  <head>
    <title>MoveNet Pose Detection</title>
    <style>
      #videoContainer {
        position: relative;
        display: inline-block;
      }
      #videoInput,
      #canvasOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 640px;
        height: 480px;
      }
      #canvasOverlay {
        z-index: 10;
      }
      #poseOutput {
        text-align: left;
        max-height: 300px;
        overflow-y: scroll;
        border: 1px solid #ddd;
        padding: 10px;
        margin-top: 500px;
      }
    </style>
  </head>
  <body>
    <div id="videoContainer">
      <video id="videoInput" width="640" height="480" autoplay></video>
      <canvas id="canvasOverlay" width="640" height="480"></canvas>
    </div>
    <div id="poseOutput"></div>
    <div style="margin-top: 10px">
      <button id="recordButton">Start Recording</button>
      <button id="downloadButton" disabled>Download Recording</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <script>
      class PoseDetector {
        constructor() {
          this.videoInput = document.getElementById("videoInput");
          this.canvasOverlay = document.getElementById("canvasOverlay");
          this.poseOutput = document.getElementById("poseOutput");
          this.ctx = this.canvasOverlay.getContext("2d");
          this.recordButton = document.getElementById("recordButton");
          this.downloadButton = document.getElementById("downloadButton");
          this.isRecording = false;
          this.recordedPoses = [];
          this.lastRecordedTime = 0;
          this.exerciseBuffer = [];
          this.BUFFER_SIZE = 3; // Store last 3 seconds of poses

          this.recordButton.addEventListener("click", () =>
            this.toggleRecording()
          );
          this.downloadButton.addEventListener("click", () =>
            this.downloadRecording()
          );
        }

        async initCamera() {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
          });
          this.videoInput.srcObject = stream;
          return new Promise((resolve) => {
            this.videoInput.onloadedmetadata = () => {
              this.videoInput.play();
              resolve();
            };
          });
        }

        async initDetector() {
          this.detector = await poseDetection.createDetector(
            poseDetection.SupportedModels.MoveNet
          );
        }

        drawKeypoints(poses) {
          this.ctx.clearRect(
            0,
            0,
            this.canvasOverlay.width,
            this.canvasOverlay.height
          );

          poses.forEach((pose) => {
            // Draw keypoints
            pose.keypoints.forEach((keypoint) => {
              if (keypoint.score > 0.5) {
                this.ctx.beginPath();
                this.ctx.arc(keypoint.x, keypoint.y, 5, 0, 2 * Math.PI);
                this.ctx.fillStyle = "red";
                this.ctx.fill();
              }
            });

            // Draw skeleton connections
            const connections = [
              ["left_shoulder", "right_shoulder"],
              ["left_hip", "right_hip"],
              ["left_shoulder", "left_hip"],
              ["right_shoulder", "right_hip"],
              ["left_shoulder", "left_elbow"],
              ["right_shoulder", "right_elbow"],
              ["left_elbow", "left_wrist"],
              ["right_elbow", "right_wrist"],
              ["left_hip", "left_knee"],
              ["right_hip", "right_knee"],
              ["left_knee", "left_ankle"],
              ["right_knee", "right_ankle"],
            ];

            this.ctx.strokeStyle = "blue";
            this.ctx.lineWidth = 2;
            connections.forEach(([from, to]) => {
              const fromPoint = pose.keypoints.find((kp) => kp.name === from);
              const toPoint = pose.keypoints.find((kp) => kp.name === to);

              if (
                fromPoint &&
                toPoint &&
                fromPoint.score > 0.5 &&
                toPoint.score > 0.5
              ) {
                this.ctx.beginPath();
                this.ctx.moveTo(fromPoint.x, fromPoint.y);
                this.ctx.lineTo(toPoint.x, toPoint.y);
                this.ctx.stroke();
              }
            });
          });
        }

        displayPoseData(poses) {
          const poseText = poses
            .map(
              (pose, index) =>
                `Pose ${index + 1} (Score: ${pose.score.toFixed(2)}):\n` +
                pose.keypoints
                  .map(
                    (kp) =>
                      `${kp.name}: (x: ${kp.x.toFixed(2)}, y: ${kp.y.toFixed(
                        2
                      )}, score: ${kp.score.toFixed(2)})`
                  )
                  .join("\n")
            )
            .join("\n\n");

          this.poseOutput.textContent = poseText;
        }

        toggleRecording() {
          this.isRecording = !this.isRecording;
          if (this.isRecording) {
            this.recordButton.textContent = "Stop Recording";
            this.recordedPoses = [];
            this.downloadButton.disabled = true;
          } else {
            this.recordButton.textContent = "Start Recording";
            this.downloadButton.disabled = false;
          }
        }

        async downloadRecording() {
          const formattedData = await Promise.all(
            this.recordedPoses.map(async (frame) => {
              const analysis = await this.analyzePose(frame.poses);

              return {
                timestamp: frame.timestamp,
                angles: analysis.angles,
                analysis: {
                  spine: analysis.analysis.spine,
                  stance_width: analysis.analysis.stance_width,
                  weight_distribution: analysis.analysis.weight_distribution,
                  heights: analysis.analysis.heights,
                  movement: analysis.analysis.movement,
                },
                keypoints: frame.poses[0].keypoints
                  .filter((kp) => kp.score > 0.5)
                  .map((kp) => ({
                    name: kp.name,
                    x: kp.x,
                    y: kp.y,
                  })),
              };
            })
          );

          const dataStr = JSON.stringify(formattedData, null, 2);
          const blob = new Blob([dataStr], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `pose_analysis_${new Date().toISOString()}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }

        getAngleBetweenPoints(a, b, c) {
          // Convert to vectors
          const vectorAB = {
            x: b.x - a.x,
            y: b.y - a.y,
          };
          const vectorBC = {
            x: c.x - b.x,
            y: c.y - b.y,
          };

          // Calculate dot product
          const dotProduct = vectorAB.x * vectorBC.x + vectorAB.y * vectorBC.y;

          // Calculate magnitudes
          const magnitudeAB = Math.sqrt(
            vectorAB.x * vectorAB.x + vectorAB.y * vectorAB.y
          );
          const magnitudeBC = Math.sqrt(
            vectorBC.x * vectorBC.x + vectorBC.y * vectorBC.y
          );

          // Calculate angle in radians
          const angleRadians = Math.acos(
            dotProduct / (magnitudeAB * magnitudeBC)
          );

          // Convert to degrees
          return 180 - (angleRadians * 180) / Math.PI;
        }

        createPoseDescription(pose) {
          const kp = Object.fromEntries(pose.keypoints.map((k) => [k.name, k]));

          // Calculate key angles
          const rightKneeAngle = this.getAngleBetweenPoints(
            kp.right_hip,
            kp.right_knee,
            kp.right_ankle
          );
          const leftKneeAngle = this.getAngleBetweenPoints(
            kp.left_hip,
            kp.left_knee,
            kp.left_ankle
          );
          const rightElbowAngle = this.getAngleBetweenPoints(
            kp.right_shoulder,
            kp.right_elbow,
            kp.right_wrist
          );
          const leftElbowAngle = this.getAngleBetweenPoints(
            kp.left_shoulder,
            kp.left_elbow,
            kp.left_wrist
          );

          // Calculate relative positions
          const torsoAngle =
            Math.atan2(
              (kp.right_shoulder.y + kp.left_shoulder.y) / 2 -
                (kp.right_hip.y + kp.left_hip.y) / 2,
              (kp.right_shoulder.x + kp.left_shoulder.x) / 2 -
                (kp.right_hip.x + kp.left_hip.x) / 2
            ) *
            (180 / Math.PI);

          return {
            head: {
              position: `The head is ${
                kp.nose.y < kp.left_shoulder.y ? "above" : "below"
              } shoulder level`,
              facing: `Face appears to be ${
                kp.left_ear.score > 0.5 && kp.right_ear.score > 0.5
                  ? "forward"
                  : kp.left_ear.score > kp.right_ear.score
                  ? "turned right"
                  : "turned left"
              }`,
            },
            torso: {
              angle: torsoAngle,
              description: `Torso is ${
                Math.abs(torsoAngle) < 15
                  ? "upright"
                  : torsoAngle > 0
                  ? "leaning forward"
                  : "leaning backward"
              }`,
            },
            arms: {
              left: {
                elbow: leftElbowAngle,
                description: `Left arm is ${
                  leftElbowAngle > 150
                    ? "straight"
                    : leftElbowAngle < 60
                    ? "tightly bent"
                    : "partially bent"
                }`,
              },
              right: {
                elbow: rightElbowAngle,
                description: `Right arm is ${
                  rightElbowAngle > 150
                    ? "straight"
                    : rightElbowAngle < 60
                    ? "tightly bent"
                    : "partially bent"
                }`,
              },
              position: `Arms are ${
                kp.left_wrist.y < kp.left_shoulder.y ? "raised" : "lowered"
              }`,
            },
            legs: {
              left: {
                knee: leftKneeAngle,
                description: `Left leg is ${
                  leftKneeAngle > 150
                    ? "straight"
                    : leftKneeAngle < 90
                    ? "deeply bent"
                    : "slightly bent"
                }`,
              },
              right: {
                knee: rightKneeAngle,
                description: `Right leg is ${
                  rightKneeAngle > 150
                    ? "straight"
                    : rightKneeAngle < 90
                    ? "deeply bent"
                    : "slightly bent"
                }`,
              },
            },
            symmetry: {
              knees:
                Math.abs(leftKneeAngle - rightKneeAngle) < 15
                  ? "symmetric"
                  : "asymmetric",
              elbows:
                Math.abs(leftElbowAngle - rightElbowAngle) < 15
                  ? "symmetric"
                  : "asymmetric",
            },
          };
        }

        async analyzePose(poses) {
          if (!poses.length) return;

          const filteredKeypoints = poses[0].keypoints.filter(
            (kp) => kp.score > 0.5
          );
          const kp = Object.fromEntries(
            filteredKeypoints.map((k) => [k.name, k])
          );

          const angles = {};
          const analysis = {};

          // Calculate joint angles
          if (kp.right_hip && kp.right_knee && kp.right_ankle) {
            angles.rightKnee = this.getAngleBetweenPoints(
              kp.right_hip,
              kp.right_knee,
              kp.right_ankle
            );
          }
          if (kp.left_hip && kp.left_knee && kp.left_ankle) {
            angles.leftKnee = this.getAngleBetweenPoints(
              kp.left_hip,
              kp.left_knee,
              kp.left_ankle
            );
          }
          if (kp.right_shoulder && kp.right_elbow && kp.right_wrist) {
            angles.rightElbow = this.getAngleBetweenPoints(
              kp.right_shoulder,
              kp.right_elbow,
              kp.right_wrist
            );
          }
          if (kp.left_shoulder && kp.left_elbow && kp.left_wrist) {
            angles.leftElbow = this.getAngleBetweenPoints(
              kp.left_shoulder,
              kp.left_elbow,
              kp.left_wrist
            );
          }
          if (
            kp.left_shoulder &&
            kp.right_shoulder &&
            kp.left_hip &&
            kp.right_hip
          ) {
            angles.torso =
              Math.atan2(
                (kp.right_shoulder.y + kp.left_shoulder.y) / 2 -
                  (kp.right_hip.y + kp.left_hip.y) / 2,
                (kp.right_shoulder.x + kp.left_shoulder.x) / 2 -
                  (kp.right_hip.x + kp.left_hip.x) / 2
              ) *
              (180 / Math.PI);
          }

          // Spine analysis
          if (
            kp.nose &&
            kp.left_shoulder &&
            kp.right_shoulder &&
            kp.left_hip &&
            kp.right_hip
          ) {
            const shoulderMidpoint = {
              x: (kp.left_shoulder.x + kp.right_shoulder.x) / 2,
              y: (kp.left_shoulder.y + kp.right_shoulder.y) / 2,
            };
            const hipMidpoint = {
              x: (kp.left_hip.x + kp.right_hip.x) / 2,
              y: (kp.left_hip.y + kp.left_hip.y) / 2,
            };

            analysis.spine = {
              forward_angle: angles.torso,
              lateral_deviation: shoulderMidpoint.x - hipMidpoint.x, // Keeping sign for direction
              head_offset: kp.nose.x - shoulderMidpoint.x, // Keeping sign for direction
            };
          }

          // Stance width (useful for many exercises)
          if (kp.left_ankle && kp.right_ankle) {
            analysis.stance_width = kp.right_ankle.x - kp.left_ankle.x;
          }

          // Weight distribution (just the raw difference)
          if (kp.left_ankle && kp.right_ankle && kp.left_hip && kp.right_hip) {
            analysis.weight_distribution =
              (kp.left_hip.y + kp.left_ankle.y) / 2 -
              (kp.right_hip.y + kp.right_ankle.y) / 2;
          }

          // Add relative heights (crucial for exercise identification)
          if (kp.nose && kp.left_shoulder && kp.right_shoulder) {
            analysis.heights = {
              // How high the head is relative to shoulders (for pushups, etc.)
              head_to_shoulder:
                kp.nose.y - (kp.left_shoulder.y + kp.right_shoulder.y) / 2,
              // Distance between shoulders and hips (for crunches, situps)
              shoulder_to_hip:
                kp.left_shoulder && kp.left_hip
                  ? Math.abs(kp.left_shoulder.y - kp.left_hip.y)
                  : null,
              // Distance from hips to ground (for squats)
              hip_to_ankle:
                kp.left_hip && kp.left_ankle
                  ? Math.abs(kp.left_hip.y - kp.left_ankle.y)
                  : null,
            };
          }

          // Add movement direction for dynamic exercises
          if (this.lastAnalysis) {
            analysis.movement = {
              vertical_velocity:
                (kp.nose?.y || 0) -
                (this.lastAnalysis.keypoints.find((k) => k.name === "nose")
                  ?.y || 0),
              is_ascending:
                analysis.heights?.head_to_shoulder <
                (this.lastAnalysis.analysis.heights?.head_to_shoulder || 0),
            };
          }
          this.lastAnalysis = { keypoints: filteredKeypoints, analysis };

          return {
            timestamp: Date.now(),
            angles,
            analysis,
            keypoints: filteredKeypoints.map((kp) => ({
              name: kp.name,
              x: kp.x,
              y: kp.y,
            })),
          };
        }

        describeMovementPattern() {
          if (this.exerciseBuffer.length < 2)
            return "Insufficient data for movement analysis";

          const latest = this.exerciseBuffer[this.exerciseBuffer.length - 1];
          const previous = this.exerciseBuffer[0];

          return `
            Angle changes (degrees):
            - Knees: ${(
              (latest.legs.left.knee -
                previous.legs.left.knee +
                latest.legs.right.knee -
                previous.legs.right.knee) /
              2
            ).toFixed(1)}°
            - Elbows: ${(
              (latest.arms.left.elbow -
                previous.arms.left.elbow +
                latest.arms.right.elbow -
                previous.arms.right.elbow) /
              2
            ).toFixed(1)}°
            - Torso: ${(latest.torso.angle - previous.torso.angle).toFixed(1)}°
          `;
        }

        async startDetection() {
          await this.initCamera();
          await this.initDetector();

          const processFrame = async () => {
            const poses = await this.detector.estimatePoses(this.videoInput);

            if (poses.length) {
              this.drawKeypoints(poses);
              this.displayPoseData(poses);

              if (this.isRecording) {
                const currentTime = Date.now();
                if (currentTime - this.lastRecordedTime >= 1000) {
                  // Store normalized keypoints for consistent measurements
                  const normalizedPoses = poses.map((pose) => ({
                    ...pose,
                    keypoints:
                      poseDetection.calculators.keypointsToNormalizedKeypoints(
                        pose.keypoints,
                        {
                          width: this.videoInput.width,
                          height: this.videoInput.height,
                        }
                      ),
                  }));

                  this.recordedPoses.push({
                    timestamp: currentTime,
                    poses: normalizedPoses, // Store the normalized poses instead of analysis
                  });

                  this.lastRecordedTime = currentTime;
                }
              }
            }

            requestAnimationFrame(processFrame);
          };

          processFrame();
        }
      }

      const detector = new PoseDetector();
      detector.startDetection();
    </script>
  </body>
</html>
